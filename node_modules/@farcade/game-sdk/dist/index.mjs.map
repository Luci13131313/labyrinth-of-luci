{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["declare global {\n  interface Window {\n    FarcadeSDK: typeof sdk\n  }\n}\n\nexport type ReadyEvent = {\n  type: 'ready'\n  data: undefined\n}\n\nexport type PlayAgainEvent = {\n  type: 'play_again'\n  data: undefined\n}\n\nexport type SinglePlayerGameOverEvent = {\n  type: 'game_over'\n  data: {\n    score: number\n  }\n}\n\nexport type MultiplayerGameOverEvent = {\n  type: 'multiplayer_game_over'\n  data: {\n    scores: {\n      playerId: string\n      score: number\n    }[]\n  }\n}\n\nexport type HapticFeedbackEvent = {\n  type: 'haptic_feedback'\n  data: undefined\n}\n\nexport type ToggleMuteEvent = {\n  type: 'toggle_mute'\n  data: {\n    isMuted: boolean\n  }\n}\n\nexport type GameErrorEvent = {\n  type: 'error'\n  data: {\n    message: string\n    source?: string\n    lineno?: number\n    colno?: number\n    error?: Error\n  }\n}\n\nexport type GameInfoEvent = {\n  type: 'game_info'\n  data: {\n    players: {\n      id: string\n      name: string\n      imageUrl?: string\n    }[]\n    meId: string\n  }\n}\n\nexport type UpdateGameStateEvent = {\n  type: 'update_game_state'\n  data: {\n    data: Record<string, unknown>\n    alertUserIds?: string[]\n  }\n}\n\nexport type GameStateUpdatedEvent = {\n  type: 'game_state_updated'\n  data: {\n    id: string\n    data: unknown\n  } | null\n}\n\nexport type RefuteGameStateEvent = {\n  type: 'refute_game_state'\n  data: {\n    gameStateId: string\n  }\n}\n\nexport type GameEvent =\n  | PlayAgainEvent\n  | SinglePlayerGameOverEvent\n  | ReadyEvent\n  | HapticFeedbackEvent\n  | ToggleMuteEvent\n  | GameErrorEvent\n  | UpdateGameStateEvent\n  | RefuteGameStateEvent\n  | GameInfoEvent\n  | GameStateUpdatedEvent\n  | MultiplayerGameOverEvent\n\nexport type GameEventMessage<T extends GameEvent['type']> = {\n  type: 'game_event'\n  event: Extract<GameEvent, { type: T }>\n}\n\n/**\n * Messages from the game host to the game client\n */\nexport type IncomingGameEvent = GameEventMessage<\n  'play_again' | 'toggle_mute' | 'game_info' | 'game_state_updated'\n>\n\nexport type OutgoingGameEvent = GameEventMessage<\n  'game_over' | 'ready' | 'haptic_feedback' | 'error' | 'update_game_state' | 'refute_game_state' | 'multiplayer_game_over'\n>\n\ntype EventCallback = (data: unknown) => void\n\nexport class FarcadeSDK {\n  private isClient: boolean\n  private target: Window | null = null\n  private eventListeners: Map<string, Set<EventCallback>> = new Map()\n\n  constructor() {\n    this.isClient = typeof window !== 'undefined'\n    this.target = this.isClient ? window.parent : null\n\n    if (this.isClient) {\n      window.addEventListener('message', this.handleMessage)\n\n      // Set up global error handler\n      window.addEventListener('error', this.handleGlobalError)\n      window.addEventListener('unhandledrejection', this.handleUnhandledRejection)\n    }\n  }\n\n  on(eventType: IncomingGameEvent['event']['type'], callback: EventCallback) {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Set())\n    }\n    this.eventListeners.get(eventType)?.add(callback)\n  }\n\n  off(eventType: IncomingGameEvent['event']['type'], callback: EventCallback) {\n    this.eventListeners.get(eventType)?.delete(callback)\n  }\n\n  setTarget(target: Window) {\n    this.target = target\n  }\n\n  singlePlayer = {\n    actions: {\n      ready: () => {\n        this.sendMessage('ready', undefined)\n      },\n      gameOver: ({ score }: SinglePlayerGameOverEvent['data']) => {\n        this.sendMessage('game_over', { score })\n      },\n      hapticFeedback: () => {\n        this.sendMessage('haptic_feedback', undefined)\n      },\n      reportError: (errorData: GameErrorEvent['data']) => {\n        this.sendMessage('error', errorData)\n      },\n    },\n  }\n\n  multiplayer = {\n    actions: {\n      ...this.singlePlayer.actions,\n      gameOver: ({ scores }: MultiplayerGameOverEvent['data']) => {\n        this.sendMessage('multiplayer_game_over', { scores })\n      },\n      updateGameState: ({ data, alertUserIds }: UpdateGameStateEvent['data']) => {\n        this.sendMessage('update_game_state', { data, alertUserIds })\n      },\n      refuteGameState: (gameStateId: string) => {\n        this.sendMessage('refute_game_state', { gameStateId })\n      },\n    },\n  }\n\n  private emit(eventType: IncomingGameEvent['event']['type'], data: unknown) {\n    for (const callback of this.eventListeners.get(eventType) || []) {\n      callback(data)\n    }\n  }\n\n  private handleMessage = (event: MessageEvent<IncomingGameEvent>) => {\n    if (event.data?.type !== 'game_event') return\n\n    this.emit(event.data.event.type, event.data.event.data)\n  }\n\n  private sendMessage = <T extends GameEvent['type']>(\n    type: T,\n    data: Extract<GameEvent, { type: T }>['data'],\n  ) => {\n    if (!this.isClient || !this.target) return\n    const gameEvent = { type: 'game_event', event: { type, data } } as GameEventMessage<T>\n    this.target.postMessage(gameEvent, '*')\n  }\n\n  private handleGlobalError = (event: globalThis.ErrorEvent) => {\n    // Send both formats for backward compatibility\n    this.sendMessage('error', {\n      message: event.message || 'Unknown error',\n      source: event.filename,\n      lineno: event.lineno,\n      colno: event.colno,\n      error: event.error,\n    })\n  }\n\n  private handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n    const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason))\n\n    // Send both formats for backward compatibility\n    this.sendMessage('error', {\n      message: error.message,\n      error,\n    })\n  }\n}\n\n// Initialize and add to window\nexport const sdk = new FarcadeSDK()\n\n// Add SDK to window object for easier access in HTML games\nwindow.FarcadeSDK = sdk\n"],
  "mappings": "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",
  "names": []
}
