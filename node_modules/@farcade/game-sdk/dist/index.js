"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FarcadeSDK: () => FarcadeSDK,
  sdk: () => sdk
});
module.exports = __toCommonJS(src_exports);
var FarcadeSDK = class {
  constructor() {
    this.target = null;
    this.eventListeners = /* @__PURE__ */ new Map();
    this.handleMessage = (event) => {
      var _a;
      if (((_a = event.data) == null ? void 0 : _a.type) !== "game_event")
        return;
      this.emit(event.data.event.type, event.data.event.data);
    };
    this.singePlayer = {
      actions: {
        ready: () => {
          this.sendMessage("ready", void 0);
        },
        gameOver: ({ score }) => {
          this.sendMessage("game_over", { score });
        },
        hapticFeedback: () => {
          this.sendMessage("haptic_feedback", void 0);
        }
      }
    };
    this.sendMessage = (type, data) => {
      if (!this.isClient || !this.target)
        return;
      const gameEvent = { type: "game_event", event: { type, data } };
      this.target.postMessage(gameEvent, "*");
    };
    this.isClient = typeof window !== "undefined";
    this.target = this.isClient ? window.parent : null;
    if (this.isClient) {
      window.addEventListener("message", this.handleMessage);
    }
  }
  on(eventType, callback) {
    var _a;
    if (!this.eventListeners.has(eventType)) {
      this.eventListeners.set(eventType, /* @__PURE__ */ new Set());
    }
    (_a = this.eventListeners.get(eventType)) == null ? void 0 : _a.add(callback);
  }
  off(eventType, callback) {
    var _a;
    (_a = this.eventListeners.get(eventType)) == null ? void 0 : _a.delete(callback);
  }
  emit(eventType, data) {
    for (const callback of this.eventListeners.get(eventType) || []) {
      callback(data);
    }
  }
  setTarget(target) {
    this.target = target;
  }
  destroy() {
    if (this.isClient) {
      window.removeEventListener("message", this.handleMessage);
    }
    this.eventListeners.clear();
  }
};
var sdk = new FarcadeSDK();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FarcadeSDK,
  sdk
});
