{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["declare global {\n  interface Window {\n    FarcadeSDK: typeof sdk\n  }\n}\n\nexport type ReadyEvent = {\n  type: 'ready'\n  data: undefined\n}\n\nexport type PlayAgainEvent = {\n  type: 'play_again'\n  data: undefined\n}\n\nexport type SinglePlayerGameOverEvent = {\n  type: 'game_over'\n  data: {\n    score: number\n  }\n}\n\nexport type MultiplayerGameOverEvent = {\n  type: 'multiplayer_game_over'\n  data: {\n    scores: {\n      playerId: string\n      score: number\n    }[]\n  }\n}\n\nexport type HapticFeedbackEvent = {\n  type: 'haptic_feedback'\n  data: undefined\n}\n\nexport type ToggleMuteEvent = {\n  type: 'toggle_mute'\n  data: {\n    isMuted: boolean\n  }\n}\n\nexport type GameErrorEvent = {\n  type: 'error'\n  data: {\n    message: string\n    source?: string\n    lineno?: number\n    colno?: number\n    error?: Error\n  }\n}\n\nexport type GameInfoEvent = {\n  type: 'game_info'\n  data: {\n    players: {\n      id: string\n      name: string\n      imageUrl?: string\n    }[]\n    meId: string\n  }\n}\n\nexport type UpdateGameStateEvent = {\n  type: 'update_game_state'\n  data: {\n    data: Record<string, unknown>\n    alertUserIds?: string[]\n  }\n}\n\nexport type GameStateUpdatedEvent = {\n  type: 'game_state_updated'\n  data: {\n    id: string\n    data: unknown\n  } | null\n}\n\nexport type RefuteGameStateEvent = {\n  type: 'refute_game_state'\n  data: {\n    gameStateId: string\n  }\n}\n\nexport type GameEvent =\n  | PlayAgainEvent\n  | SinglePlayerGameOverEvent\n  | ReadyEvent\n  | HapticFeedbackEvent\n  | ToggleMuteEvent\n  | GameErrorEvent\n  | UpdateGameStateEvent\n  | RefuteGameStateEvent\n  | GameInfoEvent\n  | GameStateUpdatedEvent\n  | MultiplayerGameOverEvent\n\nexport type GameEventMessage<T extends GameEvent['type']> = {\n  type: 'game_event'\n  event: Extract<GameEvent, { type: T }>\n}\n\n/**\n * Messages from the game host to the game client\n */\nexport type IncomingGameEvent = GameEventMessage<\n  'play_again' | 'toggle_mute' | 'game_info' | 'game_state_updated'\n>\n\nexport type OutgoingGameEvent = GameEventMessage<\n  'game_over' | 'ready' | 'haptic_feedback' | 'error' | 'update_game_state' | 'refute_game_state' | 'multiplayer_game_over'\n>\n\ntype EventCallback = (data: unknown) => void\n\nexport class FarcadeSDK {\n  private isClient: boolean\n  private target: Window | null = null\n  private eventListeners: Map<string, Set<EventCallback>> = new Map()\n\n  constructor() {\n    this.isClient = typeof window !== 'undefined'\n    this.target = this.isClient ? window.parent : null\n\n    if (this.isClient) {\n      window.addEventListener('message', this.handleMessage)\n\n      // Set up global error handler\n      window.addEventListener('error', this.handleGlobalError)\n      window.addEventListener('unhandledrejection', this.handleUnhandledRejection)\n    }\n  }\n\n  on(eventType: IncomingGameEvent['event']['type'], callback: EventCallback) {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Set())\n    }\n    this.eventListeners.get(eventType)?.add(callback)\n  }\n\n  off(eventType: IncomingGameEvent['event']['type'], callback: EventCallback) {\n    this.eventListeners.get(eventType)?.delete(callback)\n  }\n\n  setTarget(target: Window) {\n    this.target = target\n  }\n\n  singlePlayer = {\n    actions: {\n      ready: () => {\n        this.sendMessage('ready', undefined)\n      },\n      gameOver: ({ score }: SinglePlayerGameOverEvent['data']) => {\n        this.sendMessage('game_over', { score })\n      },\n      hapticFeedback: () => {\n        this.sendMessage('haptic_feedback', undefined)\n      },\n      reportError: (errorData: GameErrorEvent['data']) => {\n        this.sendMessage('error', errorData)\n      },\n    },\n  }\n\n  multiplayer = {\n    actions: {\n      ...this.singlePlayer.actions,\n      gameOver: ({ scores }: MultiplayerGameOverEvent['data']) => {\n        this.sendMessage('multiplayer_game_over', { scores })\n      },\n      updateGameState: ({ data, alertUserIds }: UpdateGameStateEvent['data']) => {\n        this.sendMessage('update_game_state', { data, alertUserIds })\n      },\n      refuteGameState: (gameStateId: string) => {\n        this.sendMessage('refute_game_state', { gameStateId })\n      },\n    },\n  }\n\n  private emit(eventType: IncomingGameEvent['event']['type'], data: unknown) {\n    for (const callback of this.eventListeners.get(eventType) || []) {\n      callback(data)\n    }\n  }\n\n  private handleMessage = (event: MessageEvent<IncomingGameEvent>) => {\n    if (event.data?.type !== 'game_event') return\n\n    this.emit(event.data.event.type, event.data.event.data)\n  }\n\n  private sendMessage = <T extends GameEvent['type']>(\n    type: T,\n    data: Extract<GameEvent, { type: T }>['data'],\n  ) => {\n    if (!this.isClient || !this.target) return\n    const gameEvent = { type: 'game_event', event: { type, data } } as GameEventMessage<T>\n    this.target.postMessage(gameEvent, '*')\n  }\n\n  private handleGlobalError = (event: globalThis.ErrorEvent) => {\n    // Send both formats for backward compatibility\n    this.sendMessage('error', {\n      message: event.message || 'Unknown error',\n      source: event.filename,\n      lineno: event.lineno,\n      colno: event.colno,\n      error: event.error,\n    })\n  }\n\n  private handleUnhandledRejection = (event: PromiseRejectionEvent) => {\n    const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason))\n\n    // Send both formats for backward compatibility\n    this.sendMessage('error', {\n      message: error.message,\n      error,\n    })\n  }\n}\n\n// Initialize and add to window\nexport const sdk = new FarcadeSDK()\n\n// Add SDK to window object for easier access in HTML games\nwindow.FarcadeSDK = sdk\n"],
  "mappings": "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",
  "names": []
}
